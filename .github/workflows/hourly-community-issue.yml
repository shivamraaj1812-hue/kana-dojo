name: Create Community Contribution Issue

on:
  schedule:
    - cron: '*/15 * * * *'
  workflow_dispatch:

permissions:
  contents: write
  issues: write
  pull-requests: write

# Prevent multiple runs from overlapping and causing race conditions
concurrency:
  group: community-issue-creation
  cancel-in-progress: false

jobs:
  create-issue:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Create community issue
        id: create-issue
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const templates = require('./.github/templates/messages.cjs');
            const t = templates.issueCreation;

            const statePath = 'data/community/automation-state.json';
            const themeBacklogPath = 'data/community/theme-backlog.json';
            const factsBacklogPath = 'data/community/facts-backlog.json';
            const proverbsBacklogPath = 'data/community/proverbs-backlog.json';

            const themesSourcePath = 'features/Preferences/data/themes.ts';
            const factsSourcePath = 'public/japan-facts.json';
            const proverbsSourcePath = 'public/japanese-proverbs.json';

            let state = JSON.parse(fs.readFileSync(statePath, 'utf8'));
            const themes = JSON.parse(fs.readFileSync(themeBacklogPath, 'utf8'));
            const facts = JSON.parse(fs.readFileSync(factsBacklogPath, 'utf8'));
            const proverbs = JSON.parse(fs.readFileSync(proverbsBacklogPath, 'utf8'));

            let backlogChanged = false;

            let existingFacts = [];
            if (fs.existsSync(factsSourcePath)) {
              try {
                existingFacts = JSON.parse(fs.readFileSync(factsSourcePath, 'utf8'));
              } catch (e) {
                console.log(`Could not parse ${factsSourcePath}: ${e.message}`);
              }
            }

            let existingProverbs = [];
            if (fs.existsSync(proverbsSourcePath)) {
              try {
                existingProverbs = JSON.parse(fs.readFileSync(proverbsSourcePath, 'utf8'));
              } catch (e) {
                console.log(`Could not parse ${proverbsSourcePath}: ${e.message}`);
              }
            }

            let themesSourceContent = '';
            if (fs.existsSync(themesSourcePath)) {
              try {
                themesSourceContent = fs.readFileSync(themesSourcePath, 'utf8');
              } catch (e) {
                console.log(`Could not read ${themesSourcePath}: ${e.message}`);
              }
            }

            async function hasOpenIssueForQuery(query) {
              const q = `${query} repo:${context.repo.owner}/${context.repo.repo} is:issue is:open`;
              try {
                const res = await github.rest.search.issuesAndPullRequests({
                  q: q,
                  per_page: 1
                });
                return res.data && res.data.total_count > 0;
              } catch (e) {
                console.log(`Search query failed: ${q} :: ${e.message}`);
                return false;
              }
            }

            // Rotate through types: theme -> fact -> proverb -> theme...
            // If a type is exhausted (or duplicates exist), try the next type within the same run
            // to avoid getting permanently stuck on an empty backlog type.
            const typeOrder = ['theme', 'fact', 'proverb'];
            const currentIndex = typeOrder.indexOf(state.lastType);

            let item, issueTitle, issueBody;
            let selectedType = null;

            for (let offset = 1; offset <= typeOrder.length; offset += 1) {
              const nextType = typeOrder[((currentIndex === -1 ? -1 : currentIndex) + offset) % typeOrder.length];
              item = null;
              issueTitle = null;
              issueBody = null;

              if (nextType === 'theme') {
              // Skip items that are already issued OR completed OR already exist in main
              item = themes.find(function(th) {
                if (th.issued || th.completed) {
                  return false;
                }
                if (themesSourceContent) {
                  const hasId = th.id && themesSourceContent.includes("id: '" + th.id + "'");
                  const hasName = th.name && themesSourceContent.toLowerCase().includes(th.name.toLowerCase());
                  if (hasId || hasName) {
                    const themeIdx = themes.findIndex(function(ti) { return ti.id === th.id; });
                    themes[themeIdx].completed = true;
                    backlogChanged = true;
                    return false;
                  }
                }
                return true;
              });
              
              if (!item) {
                console.log('No more themes available in backlog.');
                if (backlogChanged) {
                  fs.writeFileSync(themeBacklogPath, JSON.stringify(themes, null, 2));
                }
                continue;
              }
              
              // Check for duplicate theme issue
              const duplicateTheme = await hasOpenIssueForQuery(`"Add New Color Theme:" "${item.name}"`);
              
              if (duplicateTheme) {
                console.log(`Issue already exists for theme "${item.name}": Marking as issued and skipping.`);
                const themeIdx = themes.findIndex(function(th) { return th.id === item.id; });
                themes[themeIdx].issued = true;
                fs.writeFileSync(themeBacklogPath, JSON.stringify(themes, null, 2));
                backlogChanged = true;

                continue;
              }
              
              const tmpl = t.theme;
              issueTitle = tmpl.title.replace('{name}', item.name);
              
              const instructions = tmpl.instructions.map((instr, i) => `${i + 1}. ${instr.replace(/{name}/g, item.name)}`);
              
              const codeBlock = `\`\`\`typescript\n{\n  id: '${item.id}',\n  backgroundColor: '${item.backgroundColor}',\n  mainColor: '${item.mainColor}',\n  secondaryColor: '${item.secondaryColor}'\n},\n\`\`\``;
              
              issueBody = `${tmpl.header.replace('{name}', item.name)}\n\n**Category:** ${tmpl.category}  \n**Difficulty:** ${tmpl.difficulty}  \n**Estimated Time:** ${tmpl.estimatedTime}\n\n---\n\n### ðŸŽ¯ Your Task\n\n${tmpl.taskDescription}\n\n${tmpl.detailsHeader}\n\n| Property | Value |\n|----------|-------|\n| **ID** | \`${item.id}\` |\n| **Background** | \`${item.backgroundColor}\` |\n| **Main Color** | \`${item.mainColor}\` |\n| **Secondary** | \`${item.secondaryColor}\` |\n\n> ${tmpl.vibeLabel} ${item.description}\n\n${tmpl.instructionsHeader}\n\n${instructions[0]}\n${instructions[1]}\n${instructions[2]}\n\n${codeBlock}\n\n${instructions[3]}\n${instructions[4]}\n${instructions[5]}\n\n---\n\n${tmpl.footer}`;
              
              const themeIndex = themes.findIndex(function(th) { return th.id === item.id; });
              themes[themeIndex].issued = true;
              fs.writeFileSync(themeBacklogPath, JSON.stringify(themes, null, 2));
              backlogChanged = true;
              
              } else if (nextType === 'fact') {
              // Skip items that are already issued OR completed OR already exist in main
              item = facts.find(function(f) {
                if (f.issued || f.completed) {
                  return false;
                }
                if (Array.isArray(existingFacts) && existingFacts.includes(f.fact)) {
                  const factIdx = facts.findIndex(function(fi) { return fi.id === f.id; });
                  facts[factIdx].completed = true;
                  backlogChanged = true;
                  return false;
                }
                return true;
              });
              
              if (!item) {
                console.log('No more facts available in backlog.');
                if (backlogChanged) {
                  fs.writeFileSync(themeBacklogPath, JSON.stringify(themes, null, 2));
                  fs.writeFileSync(factsBacklogPath, JSON.stringify(facts, null, 2));
                  fs.writeFileSync(proverbsBacklogPath, JSON.stringify(proverbs, null, 2));
                }
                continue;
              }
              
              // Check for duplicate fact issue
              const duplicateFact = await hasOpenIssueForQuery(`"Add Japan Fact #${item.id}"`);
              
              if (duplicateFact) {
                console.log(`Issue already exists for fact #${item.id}: Marking as issued and skipping.`);
                const factIdx = facts.findIndex(function(f) { return f.id === item.id; });
                facts[factIdx].issued = true;
                fs.writeFileSync(factsBacklogPath, JSON.stringify(facts, null, 2));
                backlogChanged = true;

                continue;
              }
              
              const tmpl = t.fact;
              issueTitle = tmpl.title.replace('{id}', item.id);
              
              const instructions = tmpl.instructions.map((instr, i) => `${i + 1}. ${instr.replace(/{id}/g, item.id)}`);
              
              issueBody = `${tmpl.header}\n\n**Category:** ${tmpl.category}  \n**Difficulty:** ${tmpl.difficulty}  \n**Estimated Time:** ${tmpl.estimatedTime}\n\n---\n\n### ðŸŽ¯ Your Task\n\n${tmpl.taskDescription}\n\n${tmpl.factHeader}\n\n> ${item.fact}\n\n${tmpl.instructionsHeader}\n\n${instructions.join('\n')}\n\n---\n\n${tmpl.footer}`;
              
              const factIndex = facts.findIndex(function(f) { return f.id === item.id; });
              facts[factIndex].issued = true;
              fs.writeFileSync(factsBacklogPath, JSON.stringify(facts, null, 2));
              backlogChanged = true;
              } else {
              // Proverb
              item = proverbs.find(function(p) {
                if (p.issued || p.completed) {
                  return false;
                }
                if (Array.isArray(existingProverbs)) {
                  const exists = existingProverbs.some(function(ep) {
                    if (!ep || typeof ep !== 'object') {
                      return false;
                    }
                    return ep.japanese === p.japanese && ep.romaji === p.romaji && ep.english === p.english;
                  });
                  if (exists) {
                    const proverbIdx = proverbs.findIndex(function(pi) { return pi.id === p.id; });
                    proverbs[proverbIdx].completed = true;
                    backlogChanged = true;
                    return false;
                  }
                }
                return true;
              });
              
              if (!item) {
                console.log('No more proverbs available in backlog.');
                if (backlogChanged) {
                  fs.writeFileSync(themeBacklogPath, JSON.stringify(themes, null, 2));
                  fs.writeFileSync(factsBacklogPath, JSON.stringify(facts, null, 2));
                  fs.writeFileSync(proverbsBacklogPath, JSON.stringify(proverbs, null, 2));
                }
                continue;
              }
              
              // Check for duplicate proverb issue
              const duplicateProverb = await hasOpenIssueForQuery(`"Add Japanese Proverb #${item.id}"`);
              
              if (duplicateProverb) {
                console.log(`Issue already exists for proverb #${item.id}: Marking as issued and skipping.`);
                const proverbIdx = proverbs.findIndex(function(p) { return p.id === item.id; });
                proverbs[proverbIdx].issued = true;
                fs.writeFileSync(proverbsBacklogPath, JSON.stringify(proverbs, null, 2));
                backlogChanged = true;

                continue;
              }
              
              const tmpl = t.proverb;
              issueTitle = tmpl.title.replace('{id}', item.id);
              
              const instructions = tmpl.instructions.map((instr, i) => `${i + 1}. ${instr.replace(/{id}/g, item.id)}`);
              
              const codeBlock = `\`\`\`json\n{\n  "japanese": "${item.japanese}",\n  "romaji": "${item.romaji}",\n  "english": "${item.english}",\n  "meaning": "${item.meaning}"\n}\n\`\`\``;
              
              issueBody = `${tmpl.header}\n\n**Category:** ${tmpl.category}  \n**Difficulty:** ${tmpl.difficulty}  \n**Estimated Time:** ${tmpl.estimatedTime}\n\n---\n\n### ðŸŽ¯ Your Task\n\n${tmpl.taskDescription}\n\n${tmpl.proverbHeader}\n\n| Japanese | Reading | English |\n|----------|---------|---------|\n| **${item.japanese}** | ${item.romaji} | ${item.english} |\n\n> ðŸ’¡ **Meaning:** ${item.meaning}\n\n${tmpl.instructionsHeader}\n\n${instructions[0]}\n${instructions[1]}\n${instructions[2]}\n\n${codeBlock}\n\n${instructions[3]}\n${instructions[4]}\n${instructions[5]}\n\n---\n\n${tmpl.footer}`;
              
              const proverbIndex = proverbs.findIndex(function(p) { return p.id === item.id; });
              proverbs[proverbIndex].issued = true;
              fs.writeFileSync(proverbsBacklogPath, JSON.stringify(proverbs, null, 2));
              backlogChanged = true;
            }

              if (issueTitle && issueBody && item) {
                selectedType = nextType;
                break;
              }
            }

            if (!selectedType) {
              console.log('No available items found across theme/fact/proverb backlogs.');
              core.setOutput('should_commit', backlogChanged ? 'true' : 'false');
              return;
            }

            const labels = templates.labels.newIssue;

            const response = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: issueTitle,
              body: issueBody,
              labels: labels
            });

            console.log(`Created issue #${response.data.number}: ${issueTitle}`);

            state.lastType = selectedType;
            state.lastRun = new Date().toISOString();
            state.totalIssuesCreated = (state.totalIssuesCreated || 0) + 1;
            fs.writeFileSync(statePath, JSON.stringify(state, null, 2));

            core.setOutput('issue_number', response.data.number);
            core.setOutput('issue_type', selectedType);
            core.setOutput('item_id', item.id);
            core.setOutput('should_commit', 'true');

      - name: Commit backlog updates
        id: commit-backlog
        if: steps.create-issue.outputs.should_commit == 'true'
        uses: peter-evans/create-pull-request@v6
        with:
          token: ${{ secrets.AUTOMATION_PR_TOKEN }}
          add-paths: |
            data/community/
          commit-message: 'chore(automation): mark item as issued'
          branch: automation/community-data/hourly-${{ github.run_id }}
          title: 'chore(automation): update community backlog'
          body: Automated update to community backlog state.
          base: main
          delete-branch: true

      - name: Auto-approve and merge automation PR
        if: steps.create-issue.outputs.should_commit == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.AUTOMATION_PR_TOKEN }}
          script: |
            const prNumber = Number(process.env.PR_NUMBER);

            async function sleep(ms) {
              return new Promise(function(resolve) { setTimeout(resolve, ms); });
            }

            if (!prNumber) {
              console.log('No PR was created; nothing to merge');
              return;
            }

            const MAX_RETRIES = 10;
            for (let i = 1; i <= MAX_RETRIES; i += 1) {
              try {
                await github.rest.pulls.merge({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prNumber,
                  merge_method: 'squash'
                });
                console.log(`Merged automation PR #${prNumber}`);

                try {
                  const { data: pr } = await github.rest.pulls.get({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: prNumber
                  });
                  const ref = pr && pr.head && pr.head.ref;
                  if (ref) {
                    await github.rest.git.deleteRef({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      ref: `heads/${ref}`
                    });
                    console.log(`Deleted automation branch: ${ref}`);
                  }
                } catch (deleteErr) {
                  console.log(`Could not delete automation branch: ${deleteErr.message}`);
                }
                return;
              } catch (e) {
                console.log(`Merge attempt ${i} failed: ${e.message}`);
                if (e.status === 409) {
                  try {
                    await github.rest.pulls.updateBranch({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      pull_number: prNumber
                    });
                    console.log(`Requested branch update for PR #${prNumber}`);
                  } catch (updateErr) {
                    console.log(`Could not update branch: ${updateErr.message}`);
                  }
                }
                if (i < MAX_RETRIES) {
                  await sleep(2000);
                }
              }
            }

            throw new Error(`Failed to merge automation PR #${prNumber}`);
        env:
          PR_NUMBER: ${{ steps.commit-backlog.outputs.pull-request-number }}
